<!DOCTYPE html>
<html>
<body style="margin:0; overflow:hidden; background:#f4f4f4;">
<canvas id="canvas"></canvas>

<script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    
    let activePoints = []; // 當前正在畫的黑線點
    let fadingSegments = []; // 存放正在淡出的棕色路徑段落
    let permanentSegments = []; // 存放你要求「持續留在螢幕」的棕色路徑
    
    let lastMousePos = null;
    const MAX_POINTS = 10;   
    const FADE_SPEED = 0.02; // 控制舊線淡出的速度

    function resize() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
    }
    window.addEventListener('resize', resize);
    resize();

    window.addEventListener('mousemove', (e) => {
        const currentPos = { x: e.clientX, y: e.clientY };

        activePoints.push(currentPos);

        // 當黑點超過 MAX_POINTS，將多出的點轉化為棕色段落
        if (activePoints.length > MAX_POINTS) {
            const oldPoint = activePoints.shift();
            
            // 這裡實作你的邏輯：
            // 如果你希望「新出現的棕色持續留在螢幕上」，我們把它加到 permanentSegments
            // 如果是滑鼠停止後產生的「舊棕色」，則放入 fadingSegments
            
            // 為了符合你說的「正在淡出的繼續淡出，新出的留下」，
            // 我們預設新轉棕色的點直接進入「永久保留區」
            if (permanentSegments.length > 0) {
                permanentSegments[permanentSegments.length - 1].points.push(oldPoint);
            } else {
                permanentSegments.push({ points: [oldPoint], color: '#8B4513' });
            }
        }
        lastMousePos = currentPos;
    });

    // 監測滑鼠停止，停止時將「當前所有點」轉為「正在淡出」的段落
    let stopTimer;
    window.addEventListener('mousemove', () => {
        clearTimeout(stopTimer);
        stopTimer = setTimeout(() => {
       if (permanentSegments.length > 0) {
                // 我們只把原本就屬於棕色的部分 (permanentSegments) 丟進淡出清單
                const brownPath = [...permanentSegments.flatMap(s => s.points)];
                
                if (brownPath.length > 1) {
                    fadingSegments.push({
                        points: brownPath,
                        opacity: 1
                    });
                }
                // 只清空棕色區，不碰 activePoints
                permanentSegments = []; 
            }
        }, 100); 
    });

    function draw() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // 1. 繪製並更新「正在淡出」的段落
        for (let i = fadingSegments.length - 1; i >= 0; i--) {
            const seg = fadingSegments[i];
            ctx.save();
            ctx.globalAlpha = seg.opacity;
            drawPath(seg.points, '#8B4513');
            ctx.restore();

            seg.opacity -= FADE_SPEED; // 持續淡出，不被新動作打斷
            if (seg.opacity <= 0) {
                fadingSegments.splice(i, 1); // 徹底消失後移除
            }
        }

        // 2. 繪製「持續留在螢幕」的棕色段落 (移動中產生的)
        permanentSegments.forEach(seg => {
            drawPath(seg.points, '#8B4513');
        });

        // 3. 繪製當前的黑線
        if (activePoints.length > 1) {
            drawPath(activePoints, 'black');
        }

        requestAnimationFrame(draw);
    }

    function drawPath(pathPoints, color) {
        if (pathPoints.length < 2) return;
        ctx.beginPath();
        ctx.setLineDash([20, 15]);
        ctx.lineWidth = 4;
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';
        ctx.strokeStyle = color;

        ctx.moveTo(pathPoints[0].x, pathPoints[0].y);
        for (let i = 1; i < pathPoints.length - 1; i++) {
            const xc = (pathPoints[i].x + pathPoints[i + 1].x) / 2;
            const yc = (pathPoints[i].y + pathPoints[i + 1].y) / 2;
            ctx.quadraticCurveTo(pathPoints[i].x, pathPoints[i].y, xc, yc);
        }
        ctx.stroke();
    }
    
    requestAnimationFrame(draw);
</script>
</body>
</html>